# -*- coding: utf-8 -*-
"""Drought_Risk_using_Machine_Learning(Rf).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1j49xfrLzr3UbnA5eSRbBHpYZfO4SmBJv
"""

!pip install --upgrade xee

!pip install -U geemap

import ee
import xarray as xr

ee.Authenticate()

ee.Initialize(
    project = "ee-my-marv",
    opt_url = 'https://earthengine-highvolume.googleapis.com'
)

import geemap

map = geemap.Map()
map

roi = map.draw_last_feature.geometry()
roi

start_date = ee.Date('2000')
end_date = ee.Date('2025')
time_diff =ee.Number( end_date.difference(start_date, 'year')).round()
years_list = ee.List.sequence(0, time_diff.subtract(1)).map(lambda x : start_date.advance(x, 'year'))
years_list

def yearly(date, col):
  start_date = ee.Date(date)
  end_date = start_date.advance(1, 'year')
  col_img = col.filterDate(start_date, end_date).mean()
  col_size = ee.Number(col_img.bandNames().size())
  return col_img.set('system:time_start', start_date.millis()).set('bandsize', col_size).set('year', start_date.format('YYYY'))

water_mask = (
    ee.ImageCollection("MODIS/061/MCD12Q1")
    .filterDate(start_date, end_date)
    .filterBounds(roi)
    .mode().select('LC_Type1').eq(17).Not()
)
water_mask

climate = (
    ee.ImageCollection("IDAHO_EPSCOR/TERRACLIMATE")
    .filterDate(start_date, end_date)
    .filterBounds(roi)
    .select(['aet', 'pdsi', 'pr', 'tmmn', 'tmmx', 'soil'])
    .map(lambda x : x.updateMask(water_mask))
)
climate

yearly_climate = ee.ImageCollection(
    years_list.map(
        lambda x : yearly(x, climate)
    )
)

yearly_climate

ds = xr.open_dataset(
    yearly_climate,
    engine = 'ee',
    crs = 'EPSG: 4326',
    scale = 0.1,
    geometry = roi
)

ds

ds = ds.sortby('time') * 1

ds.pdsi.plot(
    x = 'lon',
    y = 'lat',
    col = 'time',
    col_wrap = 6,
    robust = True
)

ds['Drought'] = ((ds.pdsi * 0.01) < -2.0 ).astype(int)
ds

df =ds.to_dataframe().dropna()
df

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, roc_auc_score, roc_curve, accuracy_score, f1_score

X= df[['aet','pr', 'tmmn','tmmx' , 'soil']]
y= df[['Drought']]
y

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=( 12, 7))
sns.heatmap(X.corr(), cmap = 'Blues')
plt.title('CORRELATION BETWEEN PREDICTORS')



X_train , X_test, y_train, y_test = train_test_split(X, y, test_size= 0.2, random_state=42)

model = RandomForestClassifier(n_estimators= 500, random_state=42)

model.fit(X_train, y_train)

y_pred = model.predict(X_test)
y_proba = model.predict_proba(X_test)

report = classification_report(y_test, y_pred)
print(report)

y_score = y_proba[:,1]

roc_score = roc_auc_score(y_test, y_score)
print(f"Score: {roc_score:2f}")

fpr, tpr, threshold = roc_curve(y_test, y_score)
plt.figure()
plt.plot(fpr, tpr, label = f"AUC: {roc_score:2f}")
plt.plot([0,1], [0,1], linestyle = '--', label= 'Random Classifier')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('AOC CURVE')
plt.legend()
plt.show()

df['risk'] = model.predict_proba(X)[:,1]
df

ds_pred = df.to_xarray().sortby(['time', 'lon', 'lat'])
ds_pred

ds_pred.pdsi.plot.contourf(
    x= 'lon',
    y = 'lat',
    col = 'time',
    col_wrap  = 7,
    robust = True
)

ds_pred.risk.plot.contourf(
    x= 'lon',
    y = 'lat',
    col = 'time',
    col_wrap  = 7,
    robust = True
)

risk = ds_pred.risk.mean(dim = 'time')

risk.plot.contourf(
    x= 'lon',
    y = 'lat',
    robust = True
)

